/**************************************************************************Partition.h - abstract division of a set or sequenceCredits:- From SIBIL, the Silwood Biocomputing Library.- By Paul-Michael Agapow, 2003, Dept. Biology, University College London,  London WC1E 6BT, UNITED KINGDOM.- <mail://p.agapow@ucl.ac.uk> <http://www.bio.ic.ac.uk/evolve/>About:- A quick and dirty solution for splitting up ranges into contiguous  groups.- Beware using SetParts(),; as noted below it has the potential to break  this class quite badly.  Changes:- Tidied and documented 00.3.1To Do:- introduce iterators?- place in sibil namespace?- shift some stuff to a .cpp file where it should be, even if inlined.**************************************************************************/#ifndef PARTITION_H#define PARTITION_H// *** INCLUDES#include "Sbl.h"#include <utility>#include <vector>#include <numeric>#include <cassert>using std::pair;using std::vector;using std::make_pair;using std::accumulate;// *** CONSTANTS & DEFINEStypedef	pair<int,int>	range_t;#define DBG_PART_VALIDINDEX(x) 	assert ((0 <= x) and (x < GetNumParts()))// *** CLASS DECLARATION *************************************************/class Partition{public:// *** LIFECYCLE	Partition	()		: mNumElements (0)		{};	Partition	(int iNumElements)		: mNumElements (iNumElements)		{ SetNumElements (iNumElements); }				// *** ACCESS	// return how many partitions are there	int	GetNumParts ()						{ return mParts.size(); }		// set how many elements there are in the range	void	SetNumElements (int iNumElements)		{			mNumElements = iNumElements;			MergeAll ();		}			// see how many elements are there	int	GetNumElements ()						{ return mNumElements; }		// how many elements in partition iIndex	int	GetNumElements (int iIndex)		{ 			DBG_PART_VALIDINDEX (iIndex);			int theFrom, theTo;			GetBounds (iIndex, theFrom, theTo);			return (theTo - theFrom + 1);		}			// find where a partition runs to and from, its bounds	void	GetBounds (int iIndex, int& iFrom, int& iTo)		{			DBG_PART_VALIDINDEX (iIndex);			iFrom = mParts[iIndex].first;			iTo = mParts[iIndex].second;		}				// does a given value fall within a set partition?	bool	Within (int iIndex, int iElement)		{			DBG_PART_VALIDINDEX (iIndex);			int theFrom, theTo;			GetBounds (iIndex, theFrom, theTo);			if ((theFrom <= iElement) and (iElement <= theTo))				return true;			else				return false;		}			// what partition does a given value fall within	int	Within (int iElement)		{			for (int i = 0; i < GetNumParts(); i++)			{				if (Within (i, iElement))					return i;			}			// if you reach here the element isn't in the part			assert (false);			return 0;		}			// *** SERVICES	// place everything wthin these indexes in one partition	void	Merge (int iIndexA, int iIndexB)		{			assert (iIndexA < iIndexB);			// create new partition			mParts[iIndexA].second = mParts[iIndexB].second;			// find start of section to be deleted			vector <range_t>::iterator p = mParts.begin();			while (*p != mParts[iIndexA])				p++;			p++;			// find end of section to be deleted			vector <range_t>::iterator q = p;			while (*q != mParts[iIndexB])				q++;			// erase			mParts.erase (p,q);		}			// place all elements in a single partition	void	MergeAll	()		{			mParts.clear ();			mParts.push_back (make_pair(0,mNumElements-1));		}			// place all elements in different partitions	void 	SplitAll ()		{			mParts.clear ();			for (int i = 0; i < mNumElements; i++)				mParts.push_back (make_pair(i,i)); 		};			// set parts according to vector	// !! Note: use this function with extreme precaution - it circumvents	// most of the point of using this class	void	SetParts (vector<int>& thePartSizes)		{			assert (accumulate (thePartSizes.begin(), thePartSizes.end(),				0) ==  mNumElements);							int theTotal = 0;			mParts.clear ();			for (int i = 0; i < (int) thePartSizes.size(); i++)			{				mParts.push_back (make_pair(theTotal,theTotal+thePartSizes[i]-1));				theTotal += thePartSizes[i];			}			assert (theTotal = mNumElements);		}				// *** DEPRECIATED & DEBUG	void	Test ();// *** INTERNALS	private:	int					mNumElements;	// what's the total num of elements	vector <range_t>	mParts;			// the boundaries of the parts	};#endif// *** END ***************************************************************/